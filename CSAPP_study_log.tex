\documentclass{article}
\usepackage{CJK}
\usepackage{type1cm}
\usepackage{color}
\usepackage{array}
\usepackage[margin=1cm,top=1cm,bottom=2cm]{geometry}
\newcommand{\red}[1]{\textcolor{red}{#1}}
\begin{document}
\begin{CJK}{UTF8}{gkai}
\end{CJK}
\begin{CJK}{UTF8}{gbsn}
\end{CJK}
\begin{CJK}{UTF8}{uyhei}
%\textcolor[rgb]{1,0,0}{\begin{math} \end{math} \begin{math}			\end{math}}
%\centerline{\Huge{CSAPP Study Log}}		\\[3ex]
\fontsize{40pt}{40pt}\selectfont
\centerline{CSAPP Study Log}			
\fontsize{25pt}{25pt}\selectfont
\centerline{\red{refinement:右脑阅读，图像阅读}}	
\fontsize{18pt}{18pt}\selectfont
\noindent\textbf{1)}		\\
最低有效字节在最前面的方式，称为小端法(little endian)	\\
最高有效字节在最前面的方式，称为大端法(big endian)	\\
\textbf{2)}			\\
$_w^u+x$无符号加法			\\[0.5ex]
表示与x相加后，取w位无符号整数		\\[0.5ex]
$_w^t+x$补码加法			\\[0.5ex]
$-_w^tx$表示x在$^t_w+$下的加法逆元	\\[0.5ex]
$-_w^ux$表示x在$_w^u+$下的加法逆元	\\[1ex]
\textbf{3)}
``试图最大化一段关键代码性能的程序员，通常会尝试源代码的各种形式''包括汇编	\\[1ex]
\textbf{4)}
精通细节是理解更深和更基本概念的先决条件	\\[1ex]
\textbf{5)}	\\
栈	stacks	\\[1ex]
栈指针	\%rsp	(stack pointer)	\\[1ex]
\textbf{6)}	\\
SAL(shift arithmetic left)	算术左移	\\
SHL(shift logical left)		逻辑左移	\\
SAR(shift arithmetic right)	算术右移	\\
SHR(shift logical right)	逻辑右移	\\[1ex]
\textbf{7)}	\\
补码	two's complement	\\
\textbf{8)}	\\
处理器通过使用流水线(pipelining)来获得高性能，在流水线中，一条指令的处理要经过一系列的阶段，每个阶段执行所需操作的一小部分(例如，从内存取指令、确定指令类型、从内存读数据、执行算术去处、向内存写数据，以及更新程序计数器)。这种方法通过重叠连续指令的步骤来获得高性能。	\\[1ex]
\textbf{9)}	\\
补码除2的幂	\\
通过移位运算来实现对应值的除法	\\
$(x<0\ ?\ x+(1<<k)-1 : x) >> k$	\\[1ex]
\textbf{10)}	\\
32位机器, typedef unsigned long long int uint64\_t; printf(``\%llu'',x)	\\
64位机器, typedef unsigned long int uint64\_t; printf(``\%lu'',x)	\\
\textbf{11)}	\\
C语言大数定义	\\
\#define max\_long 9223372036854775808llu	\\
\textbf{12)}	\\
linux编译C程序为二进制可执行文件	\\
gcc -O0 -g -o p p1.c p2.c	\\
linux编译C程序为汇编代码文件	\\
gcc -O0 -g -S -o mstore.s mstore.c	\\
linux编译汇编代码为二进制可执行文件	\\
gcc -o ./mstore ./mstore.s	\\
linux编译C程序为二进制可执行文件	\\
gcc -O0 -g -c mstore.c	\\
linux反编译二进制文件产生汇编代码	\\
objdump -d ./unsigned\_flow $>$ ./binary\_unsigned\_flow.asm	\\
\textbf{13)}	\\
条件码CF:进位标志。最近的操作使最高位产生了进位。可用来检查无符号操作的溢出。\red{0-1也会产生无符号溢出}	\\
\textbf{14)}
逆向工程循环	\\
我们描述 fact\_do 的过程对于逆向工程循环来说，是一个通用的策略。看看在循环之前如何初始化寄存器，在循环中如何更新和测试寄存器，以及在循环之后又如何使用寄存器。这些步骤中的每一步都提供了一个线索，纵使起来就可以解开谜团。做好准备，你会看到令人惊奇的变换，其中有些情况很明显是编译器能够优化代码，而有些情况很难理解编译器为什么要选用那些奇怪的策略。\red{根据我们的经验，GCC常常做的一些变换，非但不能带来性能好处，反而甚至可能降低代码性能。}	\\[2ex]
\textbf{\red{ 图灵机理论以及其它一些基础而重要的理论需要了解学习 }}	\\
\textbf{15)}	\\
简洁性与普适性是计算机系统追求的普适方向	\\
\textbf{16)}	\\
图灵机是对现实世界的高度抽象与建模，正因如此现代计算机的应用领域才会如此宽广，才能在各行各业具象化	\\
\textbf{17)}	\\
从汇编代码可以看出任何独立程序都有返回值\%rax	\\
\textbf{18)}	\\
在计算机领域,由于信息在最底层，从物理上都是以二进制存储的，因经，结合二进制的信息特性与处理的位运算特性(与\&，或$|$，非！，异或\^{}),可以从二进制的处理上设计出一些十分高效的代码。	\\
例如：	\\[-2ex]
\begin{table}[ht]
\begin{tabular}{m{2em}m{2em}m{2em}l}
	\multicolumn{3}{l}{long fun\_a(unsigned long x)}	\\
\{	\\
	&	\multicolumn{3}{l}{long val = 0;}	\\
	&	\multicolumn{3}{l}{ while (x != 0) \{ } 	\\
	&	&	\multicolumn{2}{l}{val = val \^{} x;}	\\
	&	&	\multicolumn{2}{l}{x = x $>>$ 1;}	\\
	&	\multicolumn{3}{l}{ \} } 	\\
	&	\multicolumn{3}{l}{val = val \& 1;} 	\\
	&	\multicolumn{3}{l}{return val;} 	\\
\}	\\
\end{tabular}
\end{table}	\\
此函数统计参数x的二进制位表示中1的个数，若位表示中有奇数个1，则返回1；有偶数个1，则返回0。	\\[1ex]
\textbf{19)}	\\
sub指令是按无符号数来减的	\\
80 00 00 00 00 00 00 00 - 1	\\
7f ff ff ff ff ff ff ff		\\[2ex]
00 00 00 00 00 00 00 00 - 1	\\
ff ff ff ff ff ff ff ff		\\[1ex]
\textbf{20)}	\\
\red{ 问题:语言对过程(函数，方法)的实现的细节，当参数太多时是存放在栈中的，此时跟过程相关的指令是否也存在这个栈中，还是过程的指定与参数，变量是分开存放在内存中.第三章后面会讲到机器级程序控制与数据的结合. }

\end{CJK}
\end{document}
